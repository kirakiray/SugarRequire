# SugarRequire

It's SugarRequire 4.0

## 为什么要使用SugarRequire

最早的前端模块化分两个阵营，CMD 和 AMD；

然而在界面逻辑的开发上，他们存在着很大的缺陷；

CMD规范模块缺乏异步的模块机制（CMD的模块不可避免的需要同步读取模块文件后编译），导致界面需要等待所有模块加载完成后，才能开始初始化逻辑，因此会导致页面上的卡顿；

AMD规范是添加依赖前置，达到按需加载的需求，并不能做到逻辑内动态的加载模块，因此会导致开发上没有使用CMD模块的顺手；

当然，不止界面逻辑的开发，包括功能业务的定制，现有的前端模块化规范也很乏力，比如项目定制分配型的产品，以上的模块化规范就不尽人意了（一个产品封装了很多很多的功能，然而只使用几个功能的需求）。

后续的前端模块化规范（UMD和es6模块等），都没有完善异步加载模块的需求，因为，大家都习惯了打包工具，最后出来的也就一个文件；

而SugarRequire的模块化就解决了上面的问题；

得益于浏览器对es7 `async await` 的支持，`Promise` 变成了一个很方便的东西，所以 SugarRequire4 会重依赖 `Promise` 来开发，抛弃以往SugarPromise的底层框架，所以旧浏览器是无法使用 SugarRequire4，它也仅支持ES6+坏境里运行，ES7环境下（能使用 `async await`）才会用得方便；

SugarRequire4 是开发给未来的浏览器使用的，并不适合现有的场景（笔者现在写下这句话，时间是2017-06-21，所有的浏览器才刚刚开始支持 `async await`）；
